

#!/bin/bash

# ============================================
# Author:       Adam Brandeis
# Filename:     .function_cpy
# Created:      2026-01-08
# Purpose:      back up filenames with date for any file or directory
# ============================================

##### ── Function cpy  ───────────────────────────────────────
##  - backs up files using filename.yyyymmdd.bak on any file or directory
##  - shortcut to cp -pr for example: cp -pr .file{,.20190505.bak}
cpy() {
  if [[ -z $1 ]] ; then
    echo -e " "
    echo -e "   ${C_GN} Use to make a .bak file with date on any file or directory ${C_NC}"
    echo -e "    Usage: cpy MyDirectory "
    echo -e "      e.g. cpy myfile"
  elif [[ -f $1 ]] || [[ -d $1 ]] ; then
    cp -pr $1{,.$(eval date '+%Y%m%d').bak}
    ls -goaltr --color=always $1 $1*.bak | grep --color=always $1 | tail -2
  elif [[ ! -f $1 ]] || [[ ! -d $1 ]]; then
    echo -e "    $C_RD \"$1\" $C_YW file or directory not found! $C_NC"
  fi
}      ##### FUNCTION END : cpy

#!/bin/bash

# ============================================
# Author:       Adam Brandeis
# Filename:     .function_dfc
# Created:      2026-01-08
# Purpose:      to show a better human-readable disk usage with colors
# ============================================

########################
## [Function dfc] #

# Show human-readable disk usage with colors:
# - Header in cyan
# - Any Use% > threshold in red (default 75)
# - Blank line, then a TOTAL line in yellow
# Usage:
#   dfc          # threshold = 75
#   dfc 85       # threshold = 85
dfc() {
  local threshold="${1:-75}"

  # ANSI colors
  local CYAN="\033[36m"
  local RED="\033[31m"
  local YELLOW="\033[33m"
  local RESET="\033[0m"

  # Prefer POSIX columns to avoid wrapping (GNU); fallback for BSD/macOS
  local df_h_cmd="df -hP"
  $df_h_cmd >/dev/null 2>&1 || df_h_cmd="df -h"

  # 1) Main table with coloring
  eval "$df_h_cmd" | awk -v th="$threshold" -v cyan="$CYAN" -v red="$RED" -v reset="$RESET" '
    NR == 1 { print cyan $0 reset; next }
    {
      # Find the Use% field robustly (handles different layouts)
      perc = -1
      for (i = 1; i <= NF; i++) {
        if ($i ~ /%$/) {
          tmp = $i; gsub("%","",tmp)
          if (tmp ~ /^[0-9]+$/) { perc = tmp + 0; break }
        }
      }
      if (perc > th) print red $0 reset
      else print $0
    }
  '

  # 2) Blank line
  printf "\n"

  # 3) Total line in yellow
  # Try GNU df --total; if unsupported (BSD/macOS), compute totals portably.
  if df -hP --total >/dev/null 2>&1; then
    # GNU path: print only the TOTAL line in yellow
    df -hP --total | awk -v yellow="$YELLOW" -v reset="$RESET" '
      NR==1 { next }                                 # skip header
      / total$/ || $1=="total" || $1=="Total" {      # match total row
        print yellow $0 reset
        found=1
      }
      END { if (!found) { } }
    '
  else
    # Portable path: compute totals in KiB, then pretty-print in human units.
    # Use -kP for 1K-blocks with POSIX layout where possible.
    local df_k_cmd="df -kP"
    $df_k_cmd >/dev/null 2>&1 || df_k_cmd="df -k"

    eval "$df_k_cmd" | awk -v yellow="$YELLOW" -v reset="$RESET" '
      BEGIN {
        total=0; used=0; avail=0
      }
      NR==1 { header=$0; next }
      {
        # POSIX df -kP columns: Filesystem 1024-blocks Used Available Capacity Mounted on
        # Try to detect numeric fields dynamically:
        # Gather numeric fields in order of appearance
        nums=0
        for (i=1;i<=NF;i++) {
          if ($i ~ /^[0-9]+$/) {
            vals[++nums]=$i+0
          }
        }
        if (nums >= 3) {
          total += vals[1]
          used  += vals[2]
          avail += vals[3]
        }
      }
      # Humanize KiB values
      function human1k(k,  u) {
        u="K"; val=k
        if (val>=1024) { val/=1024; u="M" }
        if (val>=1024) { val/=1024; u="G" }
        if (val>=1024) { val/=1024; u="T" }
        # Show one decimal for non-integers
        if (val>=10) printf "%.0f%s", val, u
        else printf "%.1f%s", val, u
      }
      END {
        cap = (total>0 ? int((used*100)/total+0.5) : 0)
        # Reconstruct a line similar to df -h output:
        # Filesystem      Size  Used Avail Use% Mounted on
        # We print label "total" and a synthetic mountpoint "-"
        printf yellow "%-20s %6s %6s %6s %3d%% %s\n" reset, \
          "total", human1k(total), human1k(used), human1k(avail), cap, "-"
      }
    '
  fi
}      ##### FUNCTION END : dfc
``



#!/bin/bash

# ============================================
# Author:       Adam Brandeis
# Filename:     .function_du_better - alias du.
# Created:      2026-01-08
# Purpose:      Show human-readable, per-item disk usage at depth 1,
#               sorted by size, with a yellow TOTAL line at the end.
# ============================================


########################
##  [Function du_better - du.] #
alias du.="du_better"
# Show human-readable, per-item disk usage at depth 1, sorted by size,
# with a yellow TOTAL line at the end.
du_better() {
  # Use current directory if none provided
  local dir="${1:-.}"

  # Verify directory exists
  if [[ ! -d "$dir" ]]; then
    printf 'Error: "%s" is not a directory.\n' "$dir" >&2
    return 1
  fi

  # Colors (prefer tput, fallback to ANSI)
  local yellow reset
  yellow="$(tput setaf 3 2>/dev/null || printf '\033[33m')"
  reset="$(tput sgr0 2>/dev/null || printf '\033[0m')"

  # Main listing: depth 1, human-readable, one filesystem, sorted by size desc,
  # ignore "denied" noise, align nicely.
  #
  # Notes:
  # - `-a` shows both files and directories
  # - `-h` makes sizes human-readable (K/M/G/T)
  # - `-x` keeps within one filesystem
  # - `--max-depth=1` limits to immediate children
  # - `sort -h -r -k1,1` sorts by the human-readable size column
  du -ahx --max-depth=1 -- "$dir" 2>&1 \
    | sort -h -r -k1,1 \
    | grep -v "denied" \
    | awk '
        NR==1 && $2=="." { next } # if the first line is the dir itself from some du variants, skip it
        {
          size=$1
          $1=""
          sub(/^[[:space:]]+/, "", $0)
          # Align sizes to 10 chars for neat columns
          printf "%10s  %s\n", size, $0
        }
      '

  # Compute and print TOTAL in yellow
  # - Use du -shx to summarize the directory only
  local total
  total="$(du -shx -- "$dir" 2>/dev/null | awk '{print $1}')"
  printf "%s%10s  %s%s\n" "$yellow" "${total:-0}" "TOTAL" "$reset"
}      ##### FUNCTION END : du_better

#!/bin/bash

# ============================================
# Author:       Adam Brandeis
# Filename:     .function_lcd
# Created:      2026-01-08
# Purpose:      enter a directory and list contents
# ============================================


########################
## [Function lcd] #
##  - ENTER AND LIST DIRECTORY
lcd() {
  if [[ $1 == '-h' ]]; then
    echo -e " "
    echo -e " ${C_YW}This is the help info for the function:${C_NC} ${C_CY} lcd ${C_NC}"
    echo -e " ${C_YW}lcd is a function that allows a user to 'cd' into a directory and 'list' the contents in a single command.${C_NC}"
    echo -e " ${C_YW}For example: ${C_NC}"
    echo -e " ${C_YW}lcd .. ${C_NC}"
    echo -e " ${C_YW}lcd ~/rtb ${C_NC}"
  elif [[ -z $1 ]]; then
    dir -latrh --color=always;
  else
    builtin cd -- "$@" && { [ "$PS1" = "" ] || dir -latrh --color=always; };
  fi
}      ##### FUNCTION END : lcd

#!/bin/bash

# ============================================
# Author:       Adam Brandeis
# Filename:     .function_lsc
# Created:      2026-01-08
# Purpose:      List files with ls -latr and show counts of dirs/files at the bottom in yellow.
# ============================================


########################
## [Function ls_with_counts - lsc] #
alias lsc="ls_with_counts"
# List files with ls -latr and show counts of dirs/files at the bottom in yellow.
ls_with_counts() {
  # Use current directory if none provided
  local dir="${1:-.}"

  # Verify directory exists
  if [[ ! -d "$dir" ]]; then
    printf 'Error: "%s" is not a directory.\n' "$dir" >&2
    return 1
  fi

  # Colors (prefer tput; fallback to ANSI)
  local yellow reset
  yellow="$(tput setaf 3 2>/dev/null || printf '\033[33m')"
  reset="$(tput sgr0 2>/dev/null || printf '\033[0m')"

  # 1) Do the listing (includes hidden files, like your -a flag requests)
  #    -l: long format
  #    -a: include entries starting with .
  #    -t: sort by modification time
  #    -r: reverse order (oldest last)
  ls -latr -- "$dir"

  # 2) Count immediate entries (non-recursive) in the directory:
  #    - Directories: -type d (everything at depth 1; . and .. are not included due to -mindepth 1)
  #    - Files:       -type f (regular files only; symlinks not counted as files)
  #    Counts include hidden items (matching ls -a behavior).
  local dir_count file_count total
  dir_count="$(find "$dir" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l | awk '{print $1}')"
  file_count="$(find "$dir" -mindepth 1 -maxdepth 1 -type f 2>/dev/null | wc -l | awk '{print $1}')"
  total=$(( dir_count + file_count ))

  # 3) Print yellow summary lines
  printf "\n%sdirs = %s%s\n"   "$yellow" "$dir_count" "$reset"
  printf "%sfiles = %s%s\n"    "$yellow" "$file_count" "$reset"
  printf "%stotal = %s%s\n"    "$yellow" "$total" "$reset"
}      ##### FUNCTION END : ls_with_counts

#!/bin/bash

# ============================================
# Author:       Adam Brandeis
# Filename:     .function_topfiles
# Created:      2026-01-20
# Purpose:      List the top N largest files recursively from the current directory
#               with a header timestamp and per-file modification date/time.
# ============================================


########################
## [Function topfiles] #
# List the top N largest files recursively from the current directory,
# with a header timestamp and per-file modification date/time.
# Usage:
#   topfiles         # default top 10
#   topfiles 5       # top 5
#   topfiles 15      # top 15
topfiles() {
  local n="${1:-10}"

  # Validate N
  if ! [[ "$n" =~ ^[0-9]+$ ]] || [[ "$n" -le 0 ]]; then
    echo "Usage: topfiles [positive_integer]" >&2
    return 2
  fi

  # Header with current timestamp (local)
  local now
  now="$(date '+%Y-%m-%d %H:%M:%S %Z')"
  echo "Top ${n} largest files under: $(pwd)"
  echo "As of: ${now}"
  echo "------------------------------------------------------------"

  # Prefer GNU find's -printf (gives size, formatted mtime, and path safely).
  # Fallback to BSD/macOS stat or GNU stat when -printf isn't available.
  if find . -type f -printf '%s\t%TY-%Tm-%Td %TH:%TM\t%p\0' >/dev/null 2>&1; then
    # GNU find path: size (bytes), mtime "YYYY-MM-DD HH:MM", path
    find . -type f -printf '%s\t%TY-%Tm-%Td %TH:%TM\t%p\0' 2>/dev/null \
      | sort -z -t $'\t' -k1,1nr \
      | head -n "$n" \
      | awk -v RS='\0' -F"\t" '
          function human(bytes,  u, v) {
            v=bytes+0; u="B";
            if (v>=1024){v/=1024;u="K"}
            if (v>=1024){v/=1024;u="M"}
            if (v>=1024){v/=1024;u="G"}
            if (v>=1024){v/=1024;u="T"}
            if (v>=10) printf "%4.0f%s", v, u; else printf "%4.1f%s", v, u
          }
          NF>=3 { printf "%8s  %-16s  %s\n", human($1), $2, $3 }'
  else
    # Fallbacks use stat to get size and mtime; null-delimited traversal via find -print0 and xargs -0.
    if stat -f '%z %N' / >/dev/null 2>&1; then
      # BSD/macOS stat: -f with %z (size), %Sm (mtime with -t), %N (path)
      # We tab-separate fields to sort cleanly.
      find . -type f -print0 2>/dev/null \
        | xargs -0 -I{} stat -f '%z\t%Sm\t%N' -t '%Y-%m-%d %H:%M' "{}" 2>/dev/null \
        | LC_ALL=C sort -t $'\t' -k1,1nr \
        | head -n "$n" \
        | awk -F"\t" '
            function human(bytes,  u, v) {
              v=bytes+0; u="B";
              if (v>=1024){v/=1024;u="K"}
              if (v>=1024){v/=1024;u="M"}
              if (v>=1024){v/=1024;u="G"}
              if (v>=1024){v/=1024;u="T"}
              if (v>=10) printf "%4.0f%s", v, u; else printf "%4.1f%s", v, u
            }
            NF>=3 { printf "%8s  %-16s  %s\n", human($1), $2, $3 }'
    elif stat -c '%s %n' / >/dev/null 2>&1; then
      # GNU stat: %s (size), %y (mtime "YYYY-MM-DD HH:MM:SS.xxxxxx +TZ"), %n (path)
      # Trim mtime to "YYYY-MM-DD HH:MM" for consistency.
      find . -type f -print0 2>/dev/null \
        | xargs -0 -I{} stat -c '%s\t%y\t%n' "{}" 2>/dev/null \
        | LC_ALL=C sort -t $'\t' -k1,1nr \
        | head -n "$n" \
        | awk -F"\t" '
            function human(bytes,  u, v) {
              v=bytes+0; u="B";
              if (v>=1024){v/=1024;u="K"}
              if (v>=1024){v/=1024;u="M"}
              if (v>=1024){v/=1024;u="G"}
              if (v>=1024){v/=1024;u="T"}
              if (v>=10) printf "%4.0f%s", v, u; else printf "%4.1f%s", v, u
            }
            {
              # mtime example: "2026-01-16 11:22:30.123456789 -0500"
              m=$2 " " $3;                        # join first two time tokens
              sub(/\.[0-9]+$/, "", m);            # drop fractional seconds
              gsub(/:[0-9][0-9]$/, "", m);        # keep YYYY-MM-DD HH:MM (optional)
              printf "%8s  %-16s  %s\n", human($1), m, $4
            }'
    else
      echo "topfiles: neither GNU find -printf nor usable stat found." >&2
      return 1
    fi
  fi
}      ##### FUNCTION END : topfiles

#!/bin/bash

# ============================================
# Author:       Adam Brandeis
# Filename:     .function_which
# Created:      2026-01-08
# Purpose:      Custom function for a better which command for unix
# ============================================


########################
## Color Variables
C_NC="\e[0m"
C_RD="\e[31m"
C_GN="\e[32m"
C_YW="\e[33m"


#####
##  Remove which as alias so function below works
if [[ $(type -t which) = "alias"  ]]; then
  unalias which
fi

#####
## [Function which ] - Finds the location of a function, alias, builtin, etc
which() {
## Written by Adam Brandeis - 2019-11-11
  if [[ -z $1 ]]; then
    echo -e "   ${C_GN} This finds the location of Functions and/or Alias, Builtin, File or Keyword ${C_NC}"
    echo -e "   ${C_GN} Usage: which <alias or funciton name or file or builtin or keyword>  ${C_NC}"
    echo -e "   ${C_GN} Usage: which <alias or function name or keyword, etc> ${C_NC}"
    echo -e "   ${C_GN} e.g.: which ll     ${C_NC}"    ## Example Alias
    echo -e "   ${C_GN} e.g.: which cpy    ${C_NC}"    ## Example Function
    echo -e "   ${C_GN} e.g.: which lcd    ${C_NC}"    ## Example Function
    echo -e "   ${C_GN} e.g.: which for    ${C_NC}"    ## Example keyword
    echo -e "   ${C_GN} e.g.: which awk    ${C_NC}"    ## Example file


  elif [[ $(type -t $1) =~ (alias|function|builtin|file|keyword)$ ]]; then
    echo -e " "
    echo -e "${C_GN}$1 is a          :${C_YW}" $(type -t $1) ${C_NC}

    if [[ $(type -t $1) == "alias" ]]; then
      type -a $1

    elif [[ $(type -t $1) == "function" ]]; then
      shopt -s extdebug
      echo -e "${C_GN}$1 is located in :${C_YW}" $(declare -F $1) ${C_NC}
      shopt -u extdebug
      echo " "
      type -a $1

    elif  [[ $(type -t $1) =~ (builtin|file|keyword)$ ]]; then
      echo -e "See          :   man $1"
      echo " "
      type -a $1
      echo " "
      man -f $1
    fi

  else
    echo " "
    echo -e "${C_RD}$1 not found or not a valid command ${C_NC}"
  fi
    echo " "
}      ##### FUNCTION END : which


